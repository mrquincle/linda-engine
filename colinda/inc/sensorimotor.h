/**
 * @file sensorimotor.h
 * @brief Sensor and motor interface
 * @author Anne C. van Rossum
 *
 * The interface with the sensors and the motors is the first stage to higher level data
 * processing like sensor fusion and actuator fission. The interpretation of the sensors as well
 * as the actuation of the actuators is so inter-twined that they are put in this same file.
 *
 * Most of the routines over here will end up in the general "linda.h" interface file, where for
 * example developNeuralNetwork() will be moved. After developing the network, it will be running
 * forever.
 * Spikes will be continuously generated by iteratively calling generateSpikes when there is input
 * available. The implemented routine interprets an array of sensor values and outputs a set
 * of spikes in the form of AER tuples in a buffer. The network operates on those spikes and
 * outputs spikes again, in another buffer. Subsequently those spikes are interpreted and will
 * write actuation values in an output array.
 */

#ifndef SENSORIMOTOR_H_
#define SENSORIMOTOR_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <aer.h>
#include <stdint.h>

#ifndef bool
#define bool uint8_t
#endif

#ifndef false
#define false 0
#endif
#ifndef true
#define true 1
#endif

	void initAER(struct AERBuffer *aerbuffer);

	bool pushAER(struct AERBuffer *aerbuffer, union AER *aertuple);

	union AER *popAER(struct AERBuffer *aerbuffer);

	uint8_t isEmptyAER(struct AERBuffer *aerbuffer);

	void emptyAERBuffer(struct AERBuffer *aerbuffer);

	void developNeuralNetwork();

	uint8_t generateSpikes(uint8_t *input, uint8_t inputbuf_size, struct AERBuffer *aerbuffer);

	uint8_t runNeuralNetwork(struct AERBuffer *in, struct AERBuffer *out);

	void interpretSpikes(struct AERBuffer *b, int16_t *output);

	uint8_t count_spikes(struct AERBuffer *b, uint8_t x, uint8_t y);

#ifdef __cplusplus
}

#endif

#endif /*SENSORIMOTOR_H_*/
